# 자바 제네릭

<br>

# 1. 제네릭이란?

제네릭은 붕어빵 틀이고, 타입은 반죽이다. 틀에는 반죽이 들어갈 빈 공간이 있다.

우리가 붕어빵 틀을 먹을 수 없고 붕어빵 틀의 빈 공간에 반죽을 넣어서 붕어빵이 만들어져야 먹을 수 있는 것 처럼,

JVM은 제네릭을 실행할 수 없고 제네릭의 빈 공간에 타입을 넣어서 완전한 코드가 만들어져야만 실행할 수 있다.

다시 말해 제네릭은 그 자체로 실행 가능한 코드가 아니라, 실행 가능한 코드를 만들기 위한 틀이다.

<br>

# 2. 제네릭을 사용하는 이유

보일러 플레이트 코드를 제네릭으로 일원화 하면 생산성을 높일 수 있다.

개발 하다 보면 내부에서 사용하는 일부 타입만 달라지고 구조적으로는 동일한 메서드 또는 클래스가 생기곤 한다. 이때 제네릭을 활용하면 여러 개의 클래스 또는 메서드를 정의할 필요가 없어진다.

```java
...
int intFunc(int e1, int e2) {...}
long longFunc(double e1, double e2) {...}
double doubleFunc(double e1, double e2) {...}
...
```

<br>

## 2.1. 그러면 그냥 Object 쓰면 되지 않나?

그렇지 않다. 그 이유는

- 타입 안전성을 보장하고
- 다운 캐스팅에 따른 성능 저하를 방지하기 위함이다.

 `Object` 타입을 사용하면 타입 안전성(Type-safty)이 깨지기 쉽다. 제네릭을 사용하면 컴파일 시점에 타입 체크가 일어나므로 타입 안전성이 보장된다. 예를 들어,

```java
List<Fruits> fruites = new ArrayList<>();
```

위의 리스트에 대해, `Fruit` 또는 그 하위 타입이 아닌 타입으로 조회 또는 할당하는 경우 컴파일 타입에 에러를 발생시켜 줄 수 있다. → Type Safe!

그러나 제네릭을 쓰지 않고 내부 요소 타입을 그냥 `Object` 로 받으면, 어떤 값이든 받을 수 있으므로, 런타임에서 타입 캐스팅과 관련한 예외가 발생하기 쉽다.

또한 내부 `Object` 객체를 사용할 때 다운 캐스팅을 수행해야 하는 경우가 많은데, 이에 따른 성능 저하도 무시할 수 없다.

<br>

# 3. 제네릭 사용하기

## 3.1. 용어 정리

본 문서에서 사용할 용어의 의미를 짚고 넘어가자.

1. Formal 매개변수 & Actual 매개변수
    
    ```java
    // 메서드 선언부
    void Foo func(Bar formalParameter) {...}
    
    // 메서드 호출부
    Bar actualParameter = new Bar();
    func(actualParameter);
    ```
    
    - Formal 매개변수 = 선언 부에 명시된 매개변수
    - Actual 매개변수 = 호출 시 전달되는 매개변수
    
2. Formal 타입 매개변수 & Actual 타입 매개변수
    
    위와 유사한 개념
    
    - Formal 타입 매개변수 = 제네릭 선언 시 명시된 타입 매개변수
    - Actual 타입 매개변수 = 제네릭 사용 시 전달된 타입 매개변수
    
3. 타입 제네릭 vs 제네릭 타입
    
    타입 제네릭이란 표현을 사용한 의도
    
    1. 타입이라는 표현은 제네릭을 클래스, 인터페이스, 열거 클래스, 등의 다양한 타입 문법에 적용 가능하다는 것을 나타내고 싶었다.
    2. 제네릭 타입과 구분하기 위해 사용했다. 예를 들어 본 문서의
        1. “제네릭 클래스” 는 **클래스**이다. 즉, 매개변수화 클래스(Parameterized Type) 을 나타낸다.
        2. “클래스 제네릭” 은 **제네릭**이다. 틀일 뿐 실행 불가능하다.
    
4. 메서드 제네릭 vs 제네릭 메서드
    
    이 역시 위와 유사한 의도로 구분했다.
    

1. 매개변수화 타입(Parameterized Type)
    - 타입 제네릭에 Actual 타입 매개변수가 전달되어 만들어진 타입
    - ex. `List<String>`

<br>

## 3.2. 선언

제네릭을 선언하려면, 클래스 또는 메서드를 정의하고 타입이 들어갈 빈 공간을 명시하면 된다.

<br>

### 3.2.1. 타입 제네릭 선언

타입 제네릭은 타입(ex. 클래스, 인터페이스 등)에 대해 적용할 수 있다.

```java
public class Foo<T> {
    private T field;
    public T nonStaticMethod(T param) {...}
}
```

- 타입 제네릭에서 명시된 Formal 타입 매개변수 T는 제네릭 내부에서 일반적인 타입처럼 사용할 수 있지만, static context 에서는 사용할 수 없다.

```java
public interface Bar<T, U> {
    T func(T t, U u);
}
```

- 다수의 formal 타입 매개변수를 명시할 수 있다.

<br>

### 3.2.2. 메서드 제네릭 선언 1 - 클래스 내부에서 선언

```java
public class Lorem {
    public static <T> void func(T t1, T t2) {...}
}
```

- 타입 제네릭에서와는 다르게, 메서드 제네릭은 static 일 수 있다.

<br>

### 3.2.3. 메서드 제네릭 선언 2 - 제네릭 내부에서 선언

```java
public class Ipsum<T> {
		// 제너릭 메서드 정의
    public <E> void func(E e) {
        System.out.println("Ipsum.func");
        System.out.println("e = " + e);
    }

    // 클래스 제네릭에서 선언한 formal 타입 매개변수 T는
    // 메서드 제네릭에서 선언한 formal 타입 매개변수 T에
    // * 가려진다. *
    public <T> void same(T t) {
        System.out.println("Ipsum.same");
        System.out.println("t = " + t);
    }

    // 혼용 가능
    public <T, U> void mixed(T t, U u) {
        System.out.println("Ipsum.mixed");
        System.out.println("t = " + t);
        System.out.println("u = " + u);
    }
}
```

- 클래스 제네릭에서 선언한 formal 매개변수와, 그 클래스 안에서 정의된 메서드 제네릭에서 선언한 formal 매개변수의 이름이 같은 경우 **가려진다**.

<br>

## 3.3. 사용

선언된 제네릭을 실행가능한 코드로 만들어 사용하려면, 제네릭의 빈 공간에 들어갈 타입을 명시해야 한다. 

<br>

### 3.3.1. 타입 제네릭에 actual 타입 매개변수 명시

```java
Foo<Integer> bar = new Foo<Integer>();
Foo<Integer> bar = new Foo<>();
```

- 선언 및 할당 식에서 우변의 actual 타입 매개변수는 추론 가능하므로 생략 가능하다.

<br>

### 3.3.2. 메서드 제네릭에서 actual 타입 매개변수 명시

```java
// 일반 클래스 내에 메서드 제네릭 정의
public class Foo {
		
		public static <T> void staticGenericMethod(T t) {
				System.out.println("Foo.staticGenericMethod");
        System.out.println("t = " + t);
        System.out.println("t.getClass() = " + t.getClass());
		}
}
```

```java
public class Bar<T> {

		// Bar 클래스 제네릭 타입 파라미터 T 가
		// 메서드 제네릭 타입 파라미터 T에 의해 가려진다.
		public <T> void genericMethod(T t) {
				System.out.println("Bar.genericMethod");
        System.out.println("t = " + t);
        System.out.println("t.getClass() = " + t.getClass());
		}
}
```

```java
public Application {
		public static void main(String... args) {
				
				// 1. actual 타입 매개변수로 추론 가능하므로 생략 가능
				Foo.staticGenericMethod(10);    // Integer
				//                      ↑
				//            Integer 로 autoboxing 됨!
				
				// 2. null 전달 시
				// Exception in thread "main" java.lang.NullPointerException
				// : Cannot invoke "Object.getClass()" because "t" is null
				Foo.staticGenericMethod(null);  // ?
				
				// 3. 가려짐 확인
				// Bar.genericMethod
				// t = hello
				// t.getClass() = class java.lang.**String
				//                                  ↑
				//          teger 가 아니라 String 으로 가려짐을 확인 가능**
				Bar<String> bar = new Bar<>();
				bar.genericMethod("hello");
		}
}
```

<br>

### 3.3.3. 매개변수화 타입은 언제 만들어질까?

컴파일 시점에 만들어진다.

- 컴파일러가 소스 코드를 정적 분석하여 제네릭에 주어진 타입으로 제네릭을 실행 가능한 코드로 변환한다.
- 다만 컴파일 시점에만 타입 매개변수에 따른 타입 검사가 이루어지고, 런타임에서는 타입을 제거(`Object` 로 처리) 한다. → 타입 소거(Type Erasure)

<br>

### 3.3.4. Actual 타입 매개변수 타입 제한

> [!Caution]
> 이는 바로 아래에서 살펴볼 [제네릭 변성 지원](https://www.notion.so/278649136c1180138b90f3fb8454416c?pvs=21)과는 무관한 내용임에 주의하기 바란다.

제네릭 formal 매개변수 선언시 <T extends Base> 와 같이 명시하여, Actual 타입 매개변수를 제한할 수 있다. 즉, 매개변수화 시킬 수 있는 타입을 특정 타입의 하위 타입으로 제한하는 것이다.

```java
public class Foo<T extends Base> {
		
		public static <T extends Base> void bar(T t) {
        System.out.println("Foo.bar");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {

        Foo<Base> baseFoo = new Foo<>();
        Foo<Derived> derivedFoo = new Foo<>();
        Foo<String> stringFoo = new Foo<>();
        //    ↑
        // Type parameter 'java.lang.String' is
        // not within its bound; should extend
        // 'org.example.Base'
        
        Foo.bar(new Derived()); // Foo.<Derived>bar(new Derived());
        Foo.bar("abc");         // Foo.<String>bar("abc")
        //        ↑
        // Required type: T
				// Provided: String
				// reason: no instance(s) of type variable(s) exist so that String conforms to Base
    }
}
```

![↑ 메서드 제네릭 타입 제한](https://github.com/user-attachments/assets/1fe6778b-e354-42f9-ad9e-fff20826093d)


↑ 메서드 제네릭 타입 제한

![↑ 클래스 제네릭 타입 제한](https://github.com/user-attachments/assets/5e45feae-8559-42a0-b402-3383a54d8fc9)


↑ 클래스 제네릭 타입 제한

<br>

# 4. 제네릭 형 변환(와일드 카드)

## 4.1. 변성(Variance) 이란?

프로그래밍 언어의 자료형 체계에서 $I$ 를 타입 매개변수 하나를 받는 타입 생성자라고 하자.

- (일반적인 클래스 생성자(ex. new String()) 가 아니라, 말 그대로 새로운 타입을 만들어 내는 프로그램 요소를 말한다)

이때 동일한 타입 생성자 $I$ 의 타입 매개변수로 서로 상속 관계에 있는 두 타입 Super 와 Sub 으로 각각 만들어진 새로운 두 매개변수화 타입 $$I \lt Super \gt $$ 와 $$I \lt Sub \gt $$ 역시 상속 관계를 가질 때, 변성을 가진다고 말한다.

- Sub 가 Super 의 하위 타입일 때, $Sub   <:   Super$  와 같이 표현한다.

새로 만들어진 두 타입 $$I \lt Super \gt $$ 와 $$I \lt Sub \gt $$ 사이의 관계가 어떤 식으로 처리하는 지에 따라 변성을 다음과 같이 분류할 수 있다.

<br>

### 4.1.1. 공변(Covariance)

$$I \lt Super \gt $$ 가 $$I \lt Sub \gt $$ 를 포함할 때 공변이다.

- $Sub$     $<:$     $Super$  
 $→$   $$I \lt Sub \gt $$     $<:$     $$I \lt Super \gt $$

<br>

### 4.1.2. 반공변(Contravariance)

반대로 $$I \lt Sub \gt $$ 가 $$I \lt Super \gt $$ 를 포함하는 관계일 때 반공변이다.

- $Sub$     $<:$     $Super$     
$→$     $$I \lt Super \gt $$     $<:$     $$I \lt Sub \gt $$

<br>

### 4.1.3. 무공변(Invariant)

$$I \lt Sub \gt $$ 와 $$I \lt Super \gt $$ 가 무관할 때, 무공변이다.

<br>

## 4.2. 자바의 변성 지원

자바는 배열 타입에 대한 변성을 지원한다.

```java
// 공변성(업 캐스팅)
Base[] base = new Derived[1];

// 반공변성(다운 캐스팅)
Derived[] derived = (Derived[]) base;
```

그러나 자바 제네릭은 무공변이므로, 객체 지향의 다형성을 활용할 수 없다.

```java
// 제네릭 공변 지원 여부 확인
ArrayList<Base> baseList = new ArrayList<>();

// 제네릭 반공변 지원 여부 확인
ArrayList<Derived> derivedList = new ArrayList<Base>();  // ❌
```

![제네릭 변성 미지원.png](https://github.com/user-attachments/assets/66bf05ae-cb10-44c6-b287-1dfaae03f27a)


유의해야 할 것은, 위에서 자바 제네릭이 무공변이라는 것이 타입 제네릭 간 상속 관계를 정의할 수 없다는 뜻이 아니라는 것이다. 타입 제네릭 간 포함 관계는 정의될 수 있다.

자바 컬렉션 라이브러리의 예를 들어보면,

- $$ArrayList \lt E \gt$$     
$<:$     $$List \lt E \gt$$     
$<:$     $$Collection \lt E \gt$$  가 성립한다.

그러나 이것이 자바 제네릭에 대한 변성 지원을 뜻하는 것은 아니다.

변성은 어디까지나 타입 생성자를 통해 만들어진 매개변수화 타입 간에 관계를 가지는가의 여부에 대한 것이다. 

<br>

## 4.3. 와일드 카드

제네릭의 매개변수화 타입 간 변성을 활용하기 위해서는 매개변수화 타입을 선언할 때 다이아몬드 연산자 안에서 사용한다.

```java
// 예시
List<? extends String> = new ArrayList<>();
List<? super Integer> = new ArrayList<>();
```

제네릭 와일드 카드는 타입 경계를 제한하여 매개변수화 타입에 대한 다형성을 활용할 수 있도록 지원한다.

> [!Caution]
> 메서드 제네릭 호출 시 전달하는 actual 매개변수 위치에 사용할 수 없음에 유의해야 한다.

```java
// ✅ 아래의 두 메서드는 메서드 제네릭이 아님을 명시하자!
//     단지, 매개변수화 타입을 메서드 파라미터로 사용하고 있을 뿐이다.
public void foo(List<? extends String>) {...}
public void foo(List<? super Integer>) {...}

// ❌ 메서드 제네릭의 formal 타입 매개변수 위치에 사용 불가
public <? extends Base> void bar() {...}
public void bar(<? extends Base> param)

// ❌ 매개변수화 메서드의 actual 타입 매개변수 위치에 사용 불가
...
		<? extends Base>bar() 
```

<br>

### 4.3.1. Upper Bounded Wildcard - 타입 상한 와일드카드

- 타입 상한을 통해 매개변수화 타입에 대한 **공변성(Covariance)**을 지원한다.
- 매개변수화 타입 선언 시 `<? extends Base>` 와 같은 형식으로  사용한다.

```java
public class Foo<T> {
		...
}
```

```java
public class Main {
		
		public static void main(String... args) {
				
				Foo<? extends Base> baseFoo = new Foo<>();
        Foo<Derived> derivedFoo = new Foo<>();

        // 업 캐스팅 가능 => 매개변수화 타입에 대한 공변성이 지원됨!
        baseFoo = derivedFoo;
		}
}
```

<br>

### 4.3.2. Lower Bounded Wildcard - 타입 하한 와일드카드

- 타입 상한을 통해 매개변수화 타입에 대한 **반공변성(Contravariance)**을 지원한다.
- 매개변수화 타입 선언 시 `<? super Base>` 와 같은 형식으로  사용한다.

```java
public class Foo<T> {
		...
}
```

```java
public class Main {
    public static void main(String[] args) {

				Foo<Base> baseFoo = new Foo<>();
        Foo<? super Derived> derivedFoo = new Foo<>();

        // 다운 캐스팅 => 매개변수화 타입에 대한 반공변성이 지원됨!
        derivedFoo = baseFoo;
    }
}
```

<br>

### 4.3.3. Unbounded Wildcard - 무제한 와일드카드

- 타입 상한을 통해 매개변수화 타입에 대한 **공변성(Covariance)**을 지원한다.
- 그러나 상한이 최상위 타입인 `Object` 이므로 사실상 무제한의 공변성을 제공할 수 있다.
- 매개변수화 타입 선언 시 `<?>` 와 같은 형식으로  사용한다.
- 사실상 `<? extends Object>` 와 동일하다.

```java
public class Foo<T> {
		...
}
```

```java
public class Main {
    public static void main(String[] args) {

        Foo<Base> baseFoo = new Foo<>();
        Foo<Derived> derivedFoo = new Foo<>();
        Foo<Objects> objectsFoo = new Foo<>();

        Foo<?> foo1 = new Foo<>();
        foo1 = baseFoo;
        foo1 = derivedFoo;
        foo1 = objectsFoo;

        Foo<? extends Object> foo2 = new Foo<>();
        foo2 = baseFoo;
        foo2 = derivedFoo;
        foo2 = objectsFoo;
    }
}
```

<br>

# 5. Raw 타입

타입 제네릭 사용 시 actual 타입 매개변수를 명시하지 않는 것이 가능하며, 이 경우 만들어지는 타입을 Raw 타입이라고 부른다.

```java
public class Foo<T> {
		...
}
```

```java
public class Main {
    public static void main(String[] args) {

        Foo foo = new Foo();
        System.out.println("foo.getClass() = " + foo.getClass());
    }
}
```

- 실행 결과
    
    > foo.getClass() = class org.example.**Foo**
    > 

Raw 타입은 타입이 제공되지 않은 경우 컴파일러가 자동적으로 만들어주는 타입으로, 제네릭이 도입되기 이전의 자바 코드와의 backward compatibility 를 유지하기 위해 존재한다.

<br>

## 5.1. Raw 타입의 문제점

Raw 타입의 경우 어떤 타입이든 올 수 있으며, 컴파일 시 타입 체크가 전혀 일어나지 않으므로 타입 안전성을 크게 해치게 된다.

<br>

### 5.1.1. 타입 캐스팅 예외 유발

```java
public class Foo<T> {
		...
}
```

```java
public class Main {
    public static void main(String[] args) {

        List rawList = new ArrayList();
        rawList.add(1);
        rawList.add("str");
        rawList.add(new Derived());

        rawList.forEach(System.out::println);

        String i1 = (String) rawList.get(0);  // ← ❌
    }
}
```

- 컴파일러는 unchecked warning 을 발생시켜 주기는 하지만 에러로 처리하지는 않는다.
    
    ![asd.png](https://github.com/user-attachments/assets/d88b8e8d-b91b-4759-97e1-90525870fc24)

    
- 요소를 꺼낸다거나 할 때, 명시적 타입 캐스팅이 필요하므로 이 과정에서 `ClassCastException` 예외 등이 발생할 수 있다.
    - 실행 결과
        
        > 1
        > 
        > 
        > str
        > 
        > Derived!
        > 
        > Exception in thread "main" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String …
        > 

<br>

### 5.1.2. 소거(Erasure)된 타입 노출

제네릭은 컴파일 시점에서는 타입 체크를 수행하나, 성능 최적화를 위해서 런타임에서는 타입을 제거한다. 이를 타입 소거라 부른다.

어쨌거나 런타임에서는 일부 Reifiable 한 타입을 제외한 나머지는 전부 Object 로 취급되기 때문에 아래 코드에서와 같이 List<Integer> 에 문자열이 정상적으로 삽입 및 조회되는 이상한 현상이 일어나게 된다. → 힙 오염(Heap Pollution)!

```java
public class Main {
    public static void main(String[] args) {

        List rawList = new ArrayList();
        List<Integer> intList = new ArrayList<>();

        rawList = intList;
        rawList.add("str");
        System.out.println(rawList.get(0));
    }
}
```

- 실행 결과
    
    > str
    > 

<br>

## 5.2. Raw vs  <Object> vs <?> vs <? extends Object>

Raw 타입은 `Object` 타입으로 매개변수화된 타입이나(ex. `List<Object>`), 무제한 와일드카드로 매개변수화된 타입(ex. `List<?>`)과 언듯 비슷해 보이지만 다음과 같은 차이점이 존재한다.

<br>

### 5.2.1. vs <Object>

`Object` 타입으로 매개변수화된 타입은 컴파일러의 타입 체크를 받으므로 최소한의 타입 안전성이 보장된다.

예를 들어, 자바 제네릭은 기본적으로 무공변(Invariance) 이므로 [앞서 살펴본 것과 같은 힙 오염](https://www.notion.so/278649136c1180138b90f3fb8454416c?pvs=21)을 방지할 수 있다.

그러나 `List<Object>` 타입의 경우 요소로 모든 값을 받을 수 있으므로 여전히 타입 캐스팅 과정에서 문제가 발생할 수 있다.

```java
public class Main {
    public static void main(String[] args) {

        List<Object> objectList = new ArrayList<>();
        objectList.add(1);
        objectList.add("String");
        objectList.add(new Derived());

        objectList.forEach(System.out::println);
        String i1 = (String) objectList.get(0);
    }
}
```

- 실행 결과
    
    > 1
    > 
    > 
    > str
    > 
    > Derived!
    > 
    > Exception in thread "main" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class java.lang.String …
    > 

<br>

### 5.2.2. vs <?>

무제한 와일드카드로 매개변수화된 타입(ex. `List<?>`) 은 컴파일러에 의해 특수하게 처리됩니다.

컴파일러는 `List<?>` 매개변수화 타입 등에 요소를 추가하는 것을 엄격하게 막습니다. 이러한 컬렉션은 사실상 읽기 전용으로만 활용될 수 있습니다.

![스크린샷 2025-09-25 164559.png](https://github.com/user-attachments/assets/981c66d1-84ab-466d-bfe8-191fb296b1d8)

<br>

### 5.2.3. vs <? extends Object>

사실상 무제한 와일드카드로 매개변수화된 타입이다.

이 매개변수화 타입이 공변성을 가지기는 하지만 컴파일러가 바로 위에서 살펴본 <?> 의 경우와 동일하게 요소를 추가하는 것을 엄격하게 막아주기 때문에 힙 오염을 방지할 수 있습니다.

![image.png]([attachment:dbb9156d-f270-4db0-af22-beedfe4fbfad:image.png](https://github.com/user-attachments/assets/c88c72d6-5bbe-467b-8e55-1aa8f55b32e7))

<br>

# 나중에…

1. 타입 소거
2. 힙 오염

에 대해서는 나중에 더 살펴보도록 하겠습니다.

---
