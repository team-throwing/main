# JIT 컴파일러와 최적화 기법

## 1. JIT 컴파일러의 정의

### 1.1. 자바 코드의 실행 방식

- 자바 컴파일러(javac)는 자바 소스코드(.java)를 기계어로 번역하지 않고, 중간 언어인 자바 바이트코드(.class)로 번역한다.
- 이는 플랫폼 호환성(휴대성)을 위함이다. - `Write once, run anywhere`
- 바이트코드는 JVM의 인터프리터에 의해 한 줄씩 기계어로 번역되어 실행된다.

### 1.2. JIT 컴파일러

- JIT 컴파일러는 자주 사용되는 코드 조각(hot spot)들을 CPU가 실행할 수 있는 기계어로 번역하여 실행 속도를 높인다.
- JIT 컴파일러는 바이트코드(.class) 를 입력으로 받아서 기계어로 번역한다. 즉, 소스코드(.java)를 직접 보지는 않는다.
- JVM은 인터프리터 방식의 휴대성을 포기하지 않으면서도, JIT 컴파일러를 통해 실행 성능 향상을 꾀했다.
- 실행 시간이 길어질수록 JVM 은 코드 패턴을 학습하여 점점 빨라진다. 이때 까지 필요한 시간을 ***Warm-up Time*** 이라고 부른다.
    #### 컴파일 방식
    - 👍 Pros.
      - 높은 성능
        - 인터프리터에 의한 해석 과정이 불필요하다.
        - 컴파일 과정에서 코드 최적화가 이루어질 수 있다.
    - 👎 Cons.
      - 플랫폼 의존성
        - 컴파일된 기계어 코드는 특정 OS 나 CPU 에 종속적이므로, 실행 환경에 따라 여러 번 컴파일해야 한다.
    #### 인터프리터 방식
    - 👍 Pros.
      - 높은 휴대성
        - 특정 플랫폼에 의존하지 않는다.
        - 별도 실행 파일을 만들 필요 없이, 바이트코드 파일만 있으면 프로그램을 실행할 수 있다.
    - 👎 Cons.
      - 낮은 성능
        - 코드를 한 줄씩 해석해서 실행하므로 비교적 느리고 메모리도 더 많이 잡아먹는다.

<br>

## 2. JIT 컴파일러의 최적화 기법

JIT 컴파일러는 컴파일 과정에서 다양한 방식의 최적화를 수행한다.
    
    ⚠️ JIT 컴파일러의 최적화는 기계어 수준에서 일어난다.
       아래에서 제시될 예시들은 어디까지나 이해를 돕기 위해 소스 코드로 표현했을 뿐이다.

### 2.1. 인라이닝(Inlining)

- 메서드의 바디를 메서드 호출 부분에 복사하여 메서드 호출 없이 실행하는 방식이다.
- 메서드 호출에 따른 오버헤드를 없앨 수 있다.

        [메서드 호출 과정]
        
          1. 호출한 코드의 주소 저장 (메서드 실행 종료 후 복귀를 위해)
          2. 메서드 코드가 저장된 주소로 점프
          3. 메서드의 스택 프레임 생성
          4. 메서드 종류 후 스택 정리
          5. 다시 원래 위치로 복귀

- 자주 사용될수록 그리고 작고 간결한 메서드일수록 인라이닝될 확률이 높아진다.
- Java 9 이후부터는 `@HotSpotIntrinsicCandidate` 등의 어노테이션이 적용된 메서드는 강제로 인라이닝 된다. 자주 호출되나 내부 로직이 단순하지 않아서 인라이닝 될 것 같지 않다면 이러한 어노테이션을 활용해보자.
- 인라이닝은 기계어 수준에서 일어난다. 바이트코드 수준에서는 여전히 메서드가 호출된다.
- c++ 의 인라인 함수와 유사한 개념이다.
- [예시]
    ```java
    public int add(int a, int b) {
        return a + b;
    }

    public void run() {
        int x = add(5, 10);  // <-- 이 부분
    }
    ```
    [인라이닝이 적용된 코드]
    ```java
    public void run() {
        int x = 5 + 10;  // <-- 이렇게 직접 넣어버림
    }
    ```
### 2.2. 루프 최적화(Loop Optimization)

- 루프 내에서 반복되는 코드를 분석해서 불필요한 연산을 줄인다.
- 대표적인 루프 최적화 유형은 다음과 같다.
  - 루프 불변식 코드 이동(Loop-invariant code motion; CPU Hoisting)
  - 루프 전개(Loop unrolling)
  - 루프 병합(Loop Fusion)
  - 루프 분리(Loop Fission/Distribution)
- 여기서는 CPU 호이스팅에 대해서만 다루어 보겠다.

#### 2.2.1. 루프 불변식 코드 이동(Loop-Invariant code motion a.k.a CPU Hoisting)

- 루프 불변식(loop-invariant)이란 프로그램의 동작에 영향을 주지 않고, 루프 본문 밖으로 이동시킬 수 있는 명령문을 말한다.
- 루프 바깥으로 이동된 루프 불변식은 더 적게 실행되므로 프로그램이 성능이 향상된다.
- [예시]

    [최적화 이전]
    ```java
    for (int i = 0; i < str.length(); i++) {  // 루프 불변식 = str.length
        ...
    }
    ```
    
    [최적화 이후]
    ```java
    int len = str.length()
    ```

- JIT 컴파일러는 루프 불변식을 루프 밖으로 꺼낸 뒤에 메모리(변수) 또는 CPU 레지스터에 저장한다. 레지스터는 CPU 가 바로 접근할 수 있는 초고속 저장공간이므로, JIT은 가능한 한 레지스터에 올리려고 시도한다.
  - 변수 값이 필요할 때 마다 메모리에 접근할 필요가 없어지므로, 성능이 향상된다.
  - JIT 컴파일러가 레지스터를 더 잘 쓰도록 만들려면 미리 변수에 담아두면 된다.

### 2.3. 죽은 코드 제거(Dead code Elimination)

- 실행 결과에 영향을 주지 않는 코드를 아예 지워버립니다. 
- [예시]
    ```java
    int x = 10;
    x = 20; // 이전 x = 10; 은 아무 의미 없으므로 덮어씌워짐

    if (false) {
        System.out.println("항상 거짓");  // <- 이 코드는 절대 실행 안 되므로 날려도 무방
    }
    ```

### 2.4. 가상 호출 제거(Devirtualization)

- 가상 호출 제거는 동적 바인딩을 정적 바인딩으로 바꿔서 동적 바인딩에 따른 오버헤드를 없애는 방식으로 성능을 최적화한다.
- 실제로 호출될 메서드가 어떤 구현체의 메서드인지 확실히 아는 경우 구현체 메서드를 직접 호출할 수 있다.

---