# 09-22 단어정리

## 1. MVC(Model-View-Controller)

- MVC 패턴은 소프트웨어를 3가지 역할로 나누어 개발하는 디자인 패턴 중 하나이다.
- MVC는 각각 Model, View, Controller의 약자로 이 세가지가 각자의 역할에 집중함으로써 코드 구조를 명확히 하고 유지보수를 쉽게 만들어 준다.
- Model은 애플리케이션의 데이터와 비즈니스 로직을 담당한다. DB 연동, 데이터 처리 및 유효성 검사와 같은 작업을 수행한다. 독립적으로 작동하며, View와 Controller와 직접적인 통신을 하지 않는다.
- View는 사용자에게 보여지는 화면(UI)을 담당한다. Model에서 받은 데이터를 표시하고 사용자의 입력(Input)을 컨트롤러에게 전달한다.
- Controller는 사용자의 요청(Input)을 받아 분석하고 적절한 모델 기능을 호출하여 데이터를 조작하거나 업데이트 한다.

### 1-1. MVC 패턴 등장 배경 요약

- MVC 등장 이전에는 하나의 서블릿 혹은 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하고 변경 생명 주기가 서로 다른 요소들이(뷰+비즈니스 로직) 결합 되어 있어 유지보수 하기가 쉽지 않았다.
- MVC 패턴을 사용하면 JSP나 서플릿으로 처리하던 것을 Controller, Model, View라는 영역으로 서로 역할을 나누어 처리할 수 있다.

### 1-2. MVC 동작 흐름

1. 사용자가 UI에서 입력을 수행
2. View는 입력을 Controller에 전달
3. Controller는 입력을 분석하고 필요한 비즈니스 로직을 Model에 위임
4. Model은 데이터를 처리하거나 가져온 후 결과를 반환
5. Controller는 이 데이터를 받아 적절한 View를 선택 또는 갱신
6. View는 결과 데이터를 사용자에게 표시

## 2. MVP(Model-View-Presenter)

- MVP(Model-View-Presenter)는 MVC의 변형 구조로 View와 Model 사이의 로직 처리를 Presenter가 담당하는 설계 패턴
- Model: 데이터 및 비즈니스 로직처리
- View: 사용자에게 보여지는 화면, Presenter에 이벤트만 전달
- Presenter: View와 Model 사이의 중재자, 모든 로직과 흐름을 담당

### 2-1. MVP 패턴 등장 배경

- View와 Controller 사이의 결합도가 높음: View가 사용자 입력을 직접 받아 Controller를 호출하고 Controller는 다시 View를 제어하는 구조이기 때문에 둘의 경계가 애매해지고 역할이 겹치는 일이 발생
- UI와 비즈니스 로직이 쉽게 섞임: 규모가 커질수록 UI에 로직이 들어가거나 Controller가 너무 많은 책임을 안게 됨
- 단위 테스트가 어려움: Controller가 View에 의존하고 View도 이벤트 처리에 관여하기 때문에 비즈니스 로직만 따로 테스트하기 어려움
- 복잡한 GUI 환경에선 구조 유지가 어려움: 특히 모바일이나 데스크탑 애플리케이션에선 MVC가 너무 단순한 구조로 복잡한 UI 흐름을 다루기엔 한계가 있음
- MVP는 View를 철저히 수동적인 존재로 만들고 모든 UI 이벤트 처리와 비즈니스 로직을 Presenter가 전담하도록 하여 MVC의 위 문제를 해결하려 함

### 2-2. MVP의 동작 흐름

1. 사용자가 View에서 버튼 클릭
2. View는 Presenter에게 해당 이벤트 전달
3. Presenter는 로직 처리 또는 Model에게 요청
4. Model에서 결과를 받아 Presenter가 판단
5. Presenter가 View에게 결과 표시를 명령

## 3. MVVM(Model - View - ViewModel)

- UI와 상태를 자동으로 바인딩하기 위한 구조적 진화
- Model: 비즈니스 로직, 데이터 처리(DB, API 등), View와 분리
- View: 사용자에게 보여지는 UI, ViewModel과 바인딩, View는 ViewModel과 양방향 바인딩(자동 상태 반영)
- ViewModel: 상태를 보관하고 View와 Model을 연결하며 View를 직접 제어하지 않음

### 3-1. MVVM 등장 배경

- Presenter가 View를 직접 제어: View의 상태 변화에 대해 Presenter가 직접 명령해야 함
- 바인딩이 없음: UI 업데이트를 수동으로 처리해야 함
- 양방향 데이터 흐름 어려움: 상태가 바뀌면 Presenter > View로 매번 전달 필요
- 위 단점을 해결하기 위해 데이터 바인딩을 통해 View와 로직을 느슨하게 연결하는 MVVM 등장

### 3-2. MVVM 흐름

1. 사용자가 View에서 이벤트
2. View는 이벤트를 ViewModel에 전달
3. ViewModel은 Model을 통해 데이터를 요청하거나 처리
4. Model에서 변경된 데이터가 ViewModel로 전달됨
5. ViewModel의 상태가 바뀌면 View는 자동으로 갱신됨(데이터 바인딩)

## 4. DTO

- 계층과 계층 사이에서 데이터를 옮기기 위한 객체
- 서버와 클라이언트, 혹은 서비스 계층과 데이터 액세스 계층 간에 데이터를 주고받을 때 사용한다.

### 4-1. DTO 특징

- 데이터 전달이 주목적이라 가변적으로 설계하는 경우가 많음
- 네트워크 전송, API 응답, 화면에서 입력받은 데이터 전송 등에 쓰임

## 5. VO

- 도메인에서 하나의 값을 표현하는 객체로 값 자체가 의미가 있어 불변으로 해야 함
- VO에는 주로 주소, 이메일, 날짜 등이 있음
- VO의 두 객체가 값이 같으면 서로 같은 것으로 인정함

### 5-1. VO의 특징

- 일반적으로 불변 객체로 설계함
- 생성 시 값을 받고 생성 후 값이 변하지 않아야 함
- equals(), hashCode() 메서드를 값 비교 기준으로 재정의 해야함

## 6. ORM(Object-Relational-Mapping)

- 객체 지향 프로그래밍 언어를 사용하는 개발자가 관계형 데이터베이스를 더 쉽게 다룰 수 있도록 도와주는 기술 또는 기법이다.
- Object: 객체
- Relational: 관계형(예: MySQL, PostgreSQL 같은 관계형 데이터베이스)
- Mapping: 두 세계를 연결

### 6-1. ORM 등장 계기

1. 객체 지향 언어와 관계형 DB의 불일치: 객체 지향 언어에서는 클래스를 사용하지만 관계형 데이터베이스는 테이블 구조여서 매번 객체 데이터를 SQL로 변환하고 DB결과를 다시 객체로 변환해야 하는 복잡성이 존재
2. 반복적인 SQL 코드 작성의 비효율: CRUD 작업에 반복적인 SQL 작성이 필요 등 생산성이 저하