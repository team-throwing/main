# 25.09.19 내용 정리

## 1. 단축평가

- 논리 연산자(&&, ||)에서 결과가 이미 결정되었으면 나머지 조건은 평가하지 않고 건너뛰는 것
- &&은 하나라도 false면 전체가 false
- || 은 하나라도 true면 전체가 true
- &과 |은 모든 조건을 무조건 평가

### 1-1. 사용 목적

- 단축 평가를 사용하면 불필요한 연산, 객체 생성, 메서드 호출을 피할 수 있고 이것은 결국 메모리 사용량을 줄이고 성능 최적화로 이어질 수 있다.

```java
if (isValid && createHeavyObject().doSomething()) {
...
}
```

위 예시에서 isValid가 false면 createHeavyObject( )는 호출되지 않는다. 즉, 힙 메모리에 객체가 올라가지 않아 메모리 낭비가 방지되고 GC부담도 줄어든다.

## 2. Jump Table

- Jump Table은 컴파일러가 switch문을 최적화할 때 사용하는 배열 형태의 분기 테이블이다.
- switch에 들어온 값을 인덱스로 활용하여 미리 만들어둔 분기(주소) 테이블을 통해 해당 case로 점프 하는 방식

### 2-1. 사용 목적

- if-else는 순차적으로 조건을 하나하나 비교해야 함 > O(n)
- switch는  Jump Table로 변환되면서 배열 인덱스처럼 접근하게 됨 > O(1)
- 속도가 매우 빠름속도가 매우 빠름

## 3. SRP(단일 책임 원칙 - Single Responsibility Principle)

- SRP는 객체지향 설계의 SOLID 원칙 중 하나이다.
- “클래스는 하나의 책임만 가져야 한다.” 즉, 하나의 클래스가 하나의 변경 이유만 가져야 한다는 뜻이다.

### 3-1. 사용 목적

- 테스트 용이: 테스트 대상이 단일 책임이므로 단위 테스트가 쉬움
- 변경 영향 최소화: 한 클래스의 변경이 다른 기능에 영향을 안 줌

## 4. 인라이닝(Inlining)

- 인라이닝은 메서드 호출을 제거하고, 호출된 메서드의 본문을 직접 삽입하는 최적화 기법이다. 즉, 메서드를 호출하지 않고 그 내용을 직접 ‘복사 붙여넣기’ 하는 것이다.
- ex) 인라이닝 예제 코드

```java
// 
public int add(int a, int b) {
    return a + b;
}

public void run() {
    int result = add(3, 5);  // 메서드 호출 발생
}
```

```java
// 인라이닝 적용 후
public void run() {
    int result = 3 + 5;  // 메서드 호출 없이 계산
}
```

- 메서드 호출 오버헤드를 없애고 직접 코드로 대체함으로써 성능이 향상된다.
- 인라이닝은 JVM의 JIT 컴파일러가 성능에 도움이 된다고 판단되면 자동으로 적용