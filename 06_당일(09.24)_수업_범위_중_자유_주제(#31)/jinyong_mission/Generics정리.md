# Generics

## 1. 제네릭스 등장 배경

- 타입 안전성: 제네릭스를 사용하면 컴파일 시점에서 타입 오류를 미리 잡을 수 있다. 이전에는 타입을 명시하지 않으면 런타임 오류가 발생할 수 있었는데 제네릭스를 사용하면 이를 방지할 수 있다.
- 코드 재사용성: 타입에 의존하지 않는 일반화된 코드를 작성할 수 있어 다양한 데이터 타입을 처리하는 코드 작성이 용이해진다.
- 컬렉션 타입 안전성: 자바에서 컬렉션(List, Map)을 사용할 때, 컬렉션에 들어가는 데이터의 타입을 미리 지정할 수 있어 불필요한 캐스팅을 줄이고 타입 안전성을 확보할 수 있다.

## 2. 제네릭스 란

- 제네릭스는 타입 매개변수를 사용하여 클래스, 인터페이스, 메서드를 정의하는 방식이다. 이를 통해 동일한 코드가 여러 데이터 타입에 대해 동작하도록 할 수 있다.

## 3. 제네릭스 예시

```java
class Box<T> {  // 제네릭스 사용
    private T value;
    
    public void setValue(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<String> box = new Box<>();  // String 타입을 지정
        box.setValue("Hello");
        String message = box.getValue();  // 강제 캐스팅 필요 없음
        System.out.println(message);
    }
}

```

### 3-1. 예시 설명

1. Box<String>처럼 제네릭 타입을 String으로 지정한다.
2. setValue 메서드에서 String 타입만 받기 때문에 타입 안전성이 보장된다.
3. getValue 메서드는 String 타입을 반환하므로 반환값을 바로 사용할 수 있다.
4. 캐스팅을 하지 않아도 타입이 안전하게 보장되며 코드가 더 깔끔하고 오류를 예방할 수 있다.

## 4. 제네릭스 동작 흐름

1. 컴파일 시 타입 안전성 검증: 제네릭스는 컴파일 시점에 타입을 검사하여 잘못된 타입을 사용하는 오류를 미리 감지한다.
2. 런타임 시 타입 파라미터 제거: 제네릭은 **타입소거**(rtpe erasure) 방식으로 동작한다. 실제로 바이트코드에는 제네릭 타입 정보가 남지 않으며 타입 매개변수는 Object로 변환된다.

## 5. 장점 요약

- 타입 안전성: 컴파일 시 타입 검사를 통해 오류를 사전에 방지한다.
- 코드 재사용: 타입에 관계없이 동작할 수 있는 일반화된 코드 작성이 가능하다.
