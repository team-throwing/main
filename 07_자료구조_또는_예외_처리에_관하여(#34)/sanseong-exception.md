# 자바 예외(Exceptions) 개념 정리

> **목표**: 코드 예시는 배제하고, 자바 예외의 개념·분류·설계·운영 관점의 베스트 프랙티스를 한눈에 정리합니다.

---

## 1) 예외란 무엇인가

* **비정상 상황을 알리고 제어 흐름을 바꾸는 메커니즘**입니다. 정상 흐름은 반환값으로, 오류 흐름은 예외로 분리하여 가독성과 안정성을 높입니다.
* 예외는 **스택 언와인딩(stack unwinding)** 과정에서 상위 호출자로 전파되며, 적절한 지점에서 복구하거나 종료 절차를 수행합니다.

---

## 2) 오류와 예외의 차이 (Error vs Exception)

* **Error**: JVM 레벨의 심각한 문제(예: OutOfMemoryError, StackOverflowError). **복구 불가** 가정. 애플리케이션이 직접 처리하지 않습니다.
* **Exception**: 애플리케이션 레벨에서 **처리 가능**한 문제. 비즈니스/환경 제약으로 인해 발생합니다.

---

## 3) 체크 예외 vs 언체크 예외

* **체크 예외(Checked)**: 컴파일러가 **처리(try-catch) 또는 선언(throws)** 을 강제. 호출자에게 **복구 책임**을 명시적으로 전달합니다. 파일/네트워크/리소스 접근 등 **예측 가능한 실패**에 사용.
* **언체크 예외(Unchecked, RuntimeException 계열)**: 강제 처리 없음. **프로그래밍 오류**(계약 위반, 인수 검증 실패, 불변식 깨짐) 또는 **복구 불가능/무의미한 상황**에 사용.
* 실무 가이드: “**복구 가능**하고 호출자가 구체 동작을 취해야 하면 **Checked**. 그 외 대부분은 **Unchecked**.”

---

## 4) Throwable 계층 구조 요약

* **Throwable**

    * **Error** (복구 불가)
    * **Exception** (복구 가능 가정)

        * **RuntimeException** (언체크)
        * (그 외) 체크 예외들

---

## 5) 대표적 예외 범주

* **검증/계약 위반**: IllegalArgumentException, IllegalStateException, NullPointerException 등
* **입출력/네트워크**: IOException, SocketTimeoutException 등 (대개 체크)
* **동시성**: InterruptedException(체크), RejectedExecutionException, TimeoutException 등
* **영속성/데이터 접근**: SQL 예외(체크) → 프레임워크에서 언체크로 변환해 일관화하는 경우가 많음
* **리플렉션/동적 로딩**: ClassNotFoundException(체크), NoSuchMethodException(체크) 등

---

## 6) 예외 설계 원칙 (API/도메인 관점)

1. **의미 있는 경계 정의**: 모듈/레이어 경계에서 **도메인 친화적 예외**로 변환(예: "잔액부족", "권한없음").
2. **최소·정확한 표면적**: 호출자가 **의사결정**할 수 있도록 원인, 상태, 힌트를 담습니다.
3. **구체적 타입 사용**: 광범위한 Exception 대신 **구체 타입**으로 분기 가능성 제공.
4. **체크 vs 언체크 판단**: 복구 가능성, 호출자 액션 필요 여부를 기준.
5. **불변식 보호**: 도메인 규칙 위반은 **즉시 예외**로 신호.

---

## 7) 예외 메시지 작성 가이드

* **사용자용 메시지**와 **운영자/개발자용 상세**를 분리(외부 노출 민감 정보 제거).
* 메시지에는 **무엇이/왜/어떻게 조치**가 담기도록: 식별자(요청/비즈니스 키), 상태값, 기대조건, 다음 행동 힌트.
* **로케일**이 필요한 경우 상위 레이어에서 국제화 처리.

---

## 8) 원인 보존과 래핑(cause chaining)

* 하위 레이어의 세부 예외를 상위 **도메인 예외로 변환**하되, **근본 원인(cause)** 을 반드시 보존합니다.
* 동일 레벨에서 중복 래핑은 피하고, **경계에서 한 번** 명확히 매핑.

---

## 9) 커스텀 예외 설계 요령

* **간결한 계층**: 사용처가 분기할 실질적 기준이 있을 때만 서브타입을 둡니다.
* **컨텍스트 보강 필드**: 식별자, 상태코드, 정책명 등 문제 해결에 필요한 최소 정보를 포함.
* **직렬화·로깅 고려**: PII/보안정보를 필드에 저장하지 않거나, 노출 경로를 통제.

---

## 10) 레이어별 처리 전략

* **도메인**: 규칙 위반은 즉시 언체크 예외로 신호(모델 무결성 보호).
* **애플리케이션 서비스**: 트랜잭션 경계에서 **복구 시도/보상/재시도** 결정. 도메인/인프라 예외를 **사용자 친화적 의미**로 변환.
* **프레젠테이션(API/웹)**: 예외를 **표준 오류 응답 포맷**으로 매핑(에러코드, 메시지, 트레이스ID). 민감정보 차단.
* **인프라(외부 I/O)**: 타임아웃, 재시도, 서킷브레이커 등 **회복 탄력성 패턴**으로 감싸고, 상위로 도메인 의미 전달.

---

## 11) 로깅 원칙

* **한 번만** 의미 있는 레벨로 로그(중복 스택트레이스 금지).
* **레벨 기준**: 사용자가 회복 불가·시스템 결함은 ERROR, 예상 가능한 실패/외부 요인 WARN, 디버깅 필요 시 DEBUG/TRACE.
* **상관관계 ID**(트레이스/스팬/요청ID)를 포함해 원인 추적 가능성 확보.

---

## 12) 성능·안정성 고려 사항

* 예외는 **비정상 경로**로 가정: 빈번한 제어 흐름에 사용하지 않습니다.
* 예외 생성·스택트레이스 비용이 있으므로 **핫패스 검증은 사전 체크**(계약 검증)로 예방.
* 대량 처리 배치에서는 **부분 실패 전략**(스킵/재시도/DLQ 등)과 함께 예외를 관리.

---

## 13) 동시성/비동기 맥락에서의 예외

* **스레드 경계**를 넘으면 예외가 **유실**될 수 있으므로 수집·전파 전략(핸들러, 콜백, 결과 래퍼, 타임아웃 정책)이 필요.
* 비동기 작업 집합에서는 **개별 실패 집계**와 **부분 성공** 정책을 분리 설계.

---

## 14) 테스트 전략

* **행위 검증 중심**: 어떤 예외가 **언제, 왜** 발생해야 하는지를 시나리오로 명세.
* 경계/에지케이스(Null, 빈 컬렉션, 시간 경과, 중복 요청, 타임아웃)에서 일관된 예외 계약을 검증.

---

## 15) 운영/UX 관점

* 사용자에게는 **조치 가능한 정보**만 제공(재시도, 입력 수정, 문의 경로 등).
* 운영 대시보드에서 **오류율, 예외 분포, 최근 급증 유형**을 모니터링하고, 알림 임계치 관리.


