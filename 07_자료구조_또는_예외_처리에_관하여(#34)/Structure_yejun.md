# Day 7 정리: 자바 컬렉션 프레임워크 (List, Set, Map) & 해시테이블

## 1. List 계열

### ArrayList
- **내부 구조**: 제네릭 기반의 연속된 메모리 배열
- **성능**:
  - 인덱싱: **O(1)** (직접 접근)
  - 중간 삽입/삭제: **O(n)** (삽입 위치 이후 모든 요소 이동)
- **크기 관리**:
  - 성장 계수: 약 1.5배
  - 리사이즈 기준: 75% (로드 팩터)
  - 초기 용량 지정: `new ArrayList<>(capacity)`
- **상속 구조**:
  - extends: AbstractList
  - implements: List, **RandomAccess**, Cloneable, Serializable
- **특징**: RandomAccess 마커 인터페이스로 인덱스 직접 접근 지원
- **적합한 용도**: 학생 명단처럼 순차적 접근이 많고 중간 삽입이 드문 경우
  


### LinkedList
- **내부 구조**: 노드 기반의 양방향 연결 리스트 (`prev`/`next` 포인터)
- **성능**:
  - 인덱싱: **O(n)** (순차 탐색)
  - 삽입/삭제: **O(1)** (노드 참조만 변경)
- **크기 제한**: 논리적으로 제한 없음
- **상속 구조**:
  - extends: AbstractSequentialList (순차적 접근)
  - implements: List, **Deque**, Cloneable, Serializable
- **특징**: Deque 인터페이스로 양방향 큐 기능 지원
- **적합한 용도**: 앞뒤 삽입/삭제가 잦은 경우, 중간 삽입/삭제에 유리

### Vector
- **내부 구조**: 동적 배열 구조
- **특징**: 모든 메서드가 **synchronized**로 스레드 안전
- **단점**: 성능 저하로 현재는 거의 사용하지 않음
- **상속 구조**:
  - extends: AbstractList
  - implements: List, RandomAccess, Cloneable, Serializable
- **설명**: ArrayList + synchronized
- **역사적 용도**: 초기 자바에서 멀티스레드 환경 지원 목적

---

## 2. 해시테이블 핵심 개념

### 충돌 발생 원리
- **원인**: 해시값을 테이블 크기로 나눈 나머지를 인덱스로 사용
- **결과**: 서로 다른 키라도 같은 인덱스로 매핑될 수 있음

### 충돌 처리 방식
- **기본 방식**: **체이닝** (버킷에 노드 연결)
- **최적화 방식**: 임계치 이상이면 **레드-블랙 트리** 변환
- **역변환**: 버킷 크기 줄어들면 다시 리스트로 변환

### HashMap 충돌 처리 메커니즘

#### 1. 버킷 내 트리 변환
- **조건**: 버킷에 노드가 8개 이상 쌓이고, 전체 버킷 수가 64 이상일 때
- **과정**: 연결 리스트 → 레드-블랙 트리 변환
- **목적**: 버킷 탐색 속도 향상 (O(n) → O(log n))
- **노드 변환**: node → TreeNode
- **노드 속성**:
  - 일반 노드: hashcode, key, value, next (단방향 연결리스트)
  - 트리 노드: hashcode, key, value, parent, left, right, color

#### 2. 해시 테이블 크기 확장
- **초기 크기**: 16개 버킷
- **확장 조건**: 75% (로드 팩터) 이상 채워질 때
- **확장 비율**: 2배로 증가
- **목적**: 해시 충돌 완화

#### 3. 리해싱(재배열) 과정
- **필요성**: 버킷 수 증가로 해시 인덱스 계산 방식 변경 (%연산 결과 값이 달라질 수 있기 때문에)
- **과정**: 기존 모든 노드를 새 배열에 재배치
- **대상**: 연결 리스트 및 트리 구조 모두
- **역변환**: 버킷 크기 줄어들면 트리 → 리스트로 변환

#### 4. 성능 보장
- **평균 성능**: O(1)
- **최악 성능**: O(log n) (트리화된 경우)
- **최악 성능 상세**: 해시테이블 탐색(O(1)) + 트리 탐색(O(log n))
- **결과**: HashMap의 성능과 안정성 향상

### 로드 팩터 (Load Factor)
- **정의**: `size / capacity`
- **기본값**: 0.75 (75% 차면 resize 발생)
- **트레이드오프**:
  - 낮은 값: 충돌↓ / 메모리 낭비↑
  - 높은 값: 메모리 효율↑ / 충돌↑

### 시간 복잡도
- **평균**: **O(1)**
- **최악 (리스트)**: 모든 키가 한 버킷에 몰릴 경우 → **O(n)**
- **최악 (트리)**: 트리화된 경우 → **O(log n)**


> **개인적 생각**
> 1. 해시테이블과 버킷 모두 동적 배열 기반으로 구현할 수 있지만, 충돌 시 데이터 관리의 효율성과 안정성을 위해 노드 기반 연결 리스트를 사용한 것 같다.
> 2. 충돌 처리를 배열로만 할 경우 탐색이 O(n)으로 비효율적이어서, 링크드리스트가 아닌 일정 조건에서 레드-블랙 트리로 변환해 성능을 개선하는 것 같다.
> 3. Java의 구조체 부재로 키-값 쌍을 객체 단위로 묶어야 하므로 노드 구조를 선택하고, 배열과 노드 조합을 채택한게 아닐까?

---

## 3. Set 계열

### HashSet
- **내부 구조**: `HashMap` 기반, 값은 dummy object
- **성능**: 평균 **O(1)** (공간 할당 제한이 없다면)
- **특징**: 순서 없음, 중복 불허
- **상속 구조**:
  - extends: AbstractSet
  - implements: Set, Cloneable, Serializable
- **적합한 용도**: 중복 없는 학번 집합

### TreeSet
- **내부 구조**: 레드-블랙 트리 기반 (균형 이진 탐색 트리)
- **성능**: 삽입/검색/삭제 **O(log n)**
- **특징**: 항상 정렬된 상태 유지
- **상속 구조**:
  - extends: AbstractSet
  - implements: NavigableSet, Cloneable, Serializable

### LinkedHashSet
- **내부 구조**: HashSet + 이중 연결 리스트
- **특징**: 삽입 순서 또는 접근 순서 보존
- **노드 속성**: hashcode, key, (insert)next, (insert)prev
- **상속 구조**:
  - extends: HashSet
  - implements: Set, Cloneable, Serializable
- **적합한 용도**: 최근 방문 URL 기록 (중복 제거 + 순서 보존)

---

## 4. Map 계열

### HashMap
- **내부 구조**: Node 기반의 해시테이블 (배열 기반 + Node 객체)
- **성능**: 평균 **O(1)**, 최악 **O(log n)** (트리화된 경우)
- **특징**: 해시테이블 기반으로 빠른 검색 제공
- **상속 구조**:
  - extends: AbstractMap
  - implements: Map, Cloneable, Serializable
- **적합한 용도**: ID → 사용자 객체 매핑


### LinkedHashMap
- **내부 구조**: 해시테이블 + 이중 연결 리스트
- **특징**: 삽입 순서 또는 접근 순서 보존
- **고급 기능**: `accessOrder=true`로 **LRU 캐시** 구현 가능
- **노드 속성**: hashcode, key, value, (insert)next, (insert)prev
- **상속 구조**:
  - extends: HashMap
  - implements: Map, Cloneable, Serializable
- **적합한 용도**: 최근 검색어 캐시

### TreeMap
- **내부 구조**: 레드-블랙 트리
- **성능**: **O(log n)**
- **특징**: 키 기준 정렬, 범위 검색/서브맵 지원
- **상속 구조**:
  - extends: AbstractMap
  - implements: NavigableMap, Cloneable, Serializable
- **적합한 용도**: 날짜 → 로그 데이터, 특정 기간 검색

---

## 5. 해시테이블 실제 적용 사례

### Redis의 해시테이블 확장 한계
- **제한사항**: 해시테이블은 무한히 확장 불가
- **Redis 사례**:
  - 모든 데이터를 인메모리 해시 구조로 저장
  - 32-bit Redis: 프로세스 주소 공간 4GB 제한
  - 해시 오버헤드로 인한 메모리 한계
  - 64-bit 구조로 전환하여 문제 해결

---

## 6. 컬렉션 비교표

### List 계열 비교

| 구현체 | 내부구현 | 인덱싱 | 삽입/삭제 | 스레드 안전성 | 대표 예시 |
|--------|----------|--------|-----------|---------------|-----------|
| ArrayList | 동적 배열 | O(1) | O(n) | X | 학생 명단 |
| LinkedList | 이중 연결리스트 | O(n) | O(1) | X | 프린터 대기열 |
| Vector | 동적 배열 | O(1) | O(n) | O | 초기 멀티스레드 컬렉션 |

### Set 계열 비교

| 구현체 | 내부구현 | 순서 | 중복 허용 | 성능 | 대표 예시 |
|--------|----------|------|-----------|------|-----------|
| HashSet | 해시테이블 | 없음 | X | O(1) | 학번 집합 |
| TreeSet | 레드-블랙 트리 | 정렬 | X | O(log n) | 점수 집합 |
| LinkedHashSet | 해시 + 링크드리스트 | 삽입/접근순 | X | O(1) | 방문 URL 기록 |

### Map 계열 비교

| 구현체 | 내부구현 | 순서 | 성능 | 대표 예시 |
|--------|----------|------|------|-----------|
| HashMap | 해시테이블 | 없음 | O(1) | ID → 사용자 |
| TreeMap | 레드-블랙 트리 | 정렬 | O(log n) | 날짜 → 로그 |
| LinkedHashMap | 해시+링크드리스트 | 삽입/접근 순 | O(1) | LRU 캐시 |

---

## 7. 자료구조 계층도

### 기본 자료구조에서 고급 자료구조로의 발전

#### 1. 배열 계열
- **배열** → **리스트(동적배열)**
  - 관련 알고리즘: Sort(Quick Sort, Merge Sort), Search(Binary Search)

#### 2. 연결 리스트 계열
- **연결 리스트** → **스택** / **큐** / **덱**

#### 3. 힙 계열
- **최대 힙** / **최소 힙** → **우선순위 큐** (메모리의 힙과는 다름)
  - 관련 알고리즘: Sort(Heap Sort)

#### 4. 트리 계열
- **트리** → **이진 탐색 트리(BST)** → **균형 이진 탐색 트리**
  - **균형 트리 종류**: AVL Tree, Red-Black Tree
  - **고급 트리**: 2-3 Tree → B Tree → B+ Tree (DB 데이터 저장에 주로 사용)

#### 5. 그래프
- 관련 알고리즘: Search(DFS, BFS)
