# 자료구조 정리

## 1. ArrayList

### 1-1. 개요

- 자바에서 가장 많이 쓰이는 동적 배열 자료구조이다.
- 내부적으로 배열을 사용하며 크기가 자동으로 늘어나면서 데이터를 유연하게 저장할 수 있다.
- 인덱스를 통한 빠른 데이터 접근이 가능하다.

### 1-2. 특징

- 인덱스 기반 조회 매우 빠름 O(1)
- 중간 삽입/삭제는 느림 O(n)
- null 저장 가능
- 자동 크기 확장

### 1-3. 동작 흐름

1. add() 호출
2. 내부 배열에 여유 공간이 있는지 확인
3. 공간이 있으면 해당 인덱스에 값 저장
4. 공간이 없으면
    
    └ 새 배열 생성 (기존 배열보다 크게)
    
    └ 기존 데이터 복사
    
    └ 새 배열에 값 저장
    
5. get(index) 호출 > 인덱스 위치 바로 반환

### 1-4. 예제 코드

```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(0));  // Java
list.remove(0);
```

## 2. LinkedList

### 2-1. 개요

- 각 요소과 이전 노드와 다음 노드를 참조하는 연결 리스트 자료구조이다.
- 크기 제한 없이 요소 추가/삭제가 유연하다.

### 2-2. 특징

- 요소 추가/삭제가 빠름 O(1)
- 인덱스 조회는 느림 O(n)
- null 저장 가능

### 2-3. 동작 흐름

1. add() 호출
2. 새 노드 생성
3. 마지막 노드의 다음 노드로 새 노드 연결, 새 노드의 이전 노드 지정
4. get(index) 호출
5. 첫 노드부터 순차 탐색하며 인덱스까지 이동
6. 해당 노드 데이터 반환

### 2-4. 예제 코드

```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(1));  // Python
list.remove(0);
```

## 3. HashMap

### 3-1. 개요

- Key와 Value 쌍으로 데이터를 저장하는 해시 테이블 기반 자료구조이다.
- 키를 해시 함수로 변환해 빠른 조회가 가능하다.

### 3-2. 특징

- 평균적으로 삽입, 조회, 삭제 모두 O(1)
- 키 중복 불가, 값 중복 가능

### 3-3. 동작 흐름

1. put(key, value) 호출
2. 키에 해시 함수 적용
3. 해시값에 대응하는 버킷(저장 위치) 선택
4. 버킷에 데이터 저장 (충돌 시 연결 리스트 또는 트리 형태로 저장)
5. get(key) 호출
6. 동일 해시값 버킷 탐색
7. 키 비교 후 값 반환

### 3-4. 예제 코드

```java
HashMap<String, Integer> map = new HashMap<>();
map.put("Alice", 90);
map.put("Bob", 85);
System.out.println(map.get("Alice"));  // 90
```

## 4. HashSet

### 4-1. 개요

- 중복 없는 유일한 값을 저장하는 집합 자료구조이다.
- 내부적으로 HashMap을 사용한다.

### 4-2. 특징

- 중복된 값은 저장하지 않음
- 평균적인 삽입, 조회, 삭제 O(1)
- 순서가 보장이 안 됨

### 4-3. 동작 흐름

1. add(value) 호출
2. 내부 HashMap의 put(value, PRESENT) 호출
3. 해시 함수 적용 후 버킷 결정
4. 값이 이미 있으면 삽입 무시
5. 없으면 새 키로 저장
6. contains(value) 호출
7. 해시값 버킷 탐색
8. 값 존재 여부 반

### 4-4. 예제 코드

```java
HashSet<String> set = new HashSet<>();
set.add("Java");
set.add("Java");  // 중복 무시
System.out.println(set.size());  // 1
```

## 5. Stack

### 5-1. 개요

- LIFO(Last In First Out) 구조로 데이터를 저장하는 자료구조이다.
- 가장 나중에 들어온 데이터가 가장 먼저 나간다.

### 5-2. 특징

- push(), pop() 메서드로 요소 추가/제거
- peek()으로 가장 위 데이터 확인 가능
- 주로 재귀, 되돌리기 기능 구현에 사용

### 5-3. 동작 흐름

1. push(value) 호출
2. 데이터 구조 맨 위에 값 추가
3. pop() 호출
4. 맨 위 데이터 반환 및 삭제
5. peek() 호출
6. 맨 위 데이터 반환 (삭제 안함)

### 5-4. 예제 코드

```java
Stack<Integer> stack = new Stack<>();
stack.push(10);
stack.push(20);
System.out.println(stack.pop());  // 20
```

## 6.Queue

### 6-1. 개요

- FIFO(First In First Out) 구조로 데이터를 저장하는 자료구조이다.
- 가장 먼저 들어온 데이터가 가장 먼저 나간다.

### 6-2.

- offer()로 요소 추가, poll()로 요소 제거
- peek()으로 앞 데이터 확인 가능
- 주로 작업 대기열, 이벤트 처리에 사용

### 6-3. 동작 흐름

1. offer(value) 호출
2. 데이터 구조 맨 뒤에 값 추가
3. poll() 호출
4. 데이터 구조 맨 앞 값 반환 및 삭제
5. peek() 호출
6. 데이터 구조 맨 앞 값 반환 (삭제 안함)

### 6-4. 예제코드

```java
Queue<Integer> queue = new LinkedList<>();
queue.offer(10);
queue.offer(20);
System.out.println(queue.poll());  // 10
```